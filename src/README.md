# [RTOS简介](https://github.com/OS-Q/RTQ)

RTOS并不保证最终的结果是实时的，实时结果的保证要求软件的正确开发，RTOS不要求高性能更为专注于执行时间的保证。

根据对实时性的区分度，分为一般截止时间的保证(软实时性soft real-time)和严格意义上截止时间的保证(硬实时性hard real-time)。

RTOS使用特定的调度算法，并在最终系统中提供给开发人员以必要的工具，确保其应用的实时性。

RTOS的性能主要用最短响应时间或最长预期反应时间或最大超时完成时间来衡量。 RTOS中最关键的因素在于最小的中断时延和最小的线程切换时延。

在一个RTOS中所写的软件的基本构造块就叫任务。任务写起来非常简单：在大多数的RTOS中的一个任务只是一个子程序。

任务(Task)是RTOS中最重要的操作对象，每个任务在RTOS的调用下由CPU分时执行。

激活的或当前任务是CPU正在执行的任务，休眠的任务是在存储器中保留其执行的上下文背景、一旦切换为当前任务即可从上次执行的末尾继续执行的任务。

任务的调度目前主要有时间分片式(TimeSlicing)、轮流查询式(Round-Robin)和优先抢占式(Preemptive)三种,不同的RTOS可能支持其中的一种或几种，其中优先抢占式对实时性的支持最好。

RTOS提供了一个函数集合，通过这个函数集合任务能告诉调度程序它正在等待什么事件发生，并且当事件发生时能发信号通知调度程序。

* [任务状态](#任务状态)
* [任务调度](#任务调度)

## 任务状态

* Runnig(运行) - 在这种状态下任务得到了CPU时间来执行它的指令。

在同一个时间点，只有一个任务能够处于这种状态。我们用RTOS的一个函数来将这种状态下的任务变回Suspended状态，这样任务就停止执行并且deactivated.我们用另一个RTOS的函数来这种状态下的任务变到Waiting状态，这时任务同样停止了执行，但是保持活动状态。
注:在多处理器系统里,在指定的时间里可能有超过一个的任务在运行.但是单处理器平台上,任何时候只能有一个任务在单独运行。

* Ready(就绪) - 任务在这种状态下是活动的并且等待进入Running状态。

我们用RTOS的调度器(scheduler)来决定在什么时候将处于Ready的任务过渡到Running状态，我们也用调度器来决定是否将任务变回到Ready状态，这取决于RTOS固有的算法以及其他任务的状态。其他的任务正在运行中,但只要处理器处于空闲状态,这个任务就能运行。大多数的任务可能会处于这个状态。

* Blocked( 阻塞) - 表示任务还没有获得运行所需要的资源，即使此时微处理器空闲也不能运行。

任务处于这个状态是因为它们在等待某些外部事件的发生。例如，处理网络数据的任务在没有数据的时候什么事情也不会做。响应用户按键事件的任务直到用户按键之后才开始工作。处于这个状态的任务有可能也存在许多。

* Suspended(挂起) - 这是系统启动后的默认状态。在这种状态下，任务为inactive。通过RTOS的激活，任务状态可以过渡为Ready。

* Waiting(等待) – 在这种状态下的任务在event(RTOS的另外一个service)进行等待。如果这个event被设置了的话，任务就变回Ready状态。

* Sleep(睡眠) - TBD(To Be Defined)
* Delay(延迟) - TBD(To Be Defined)

## 任务调度

两种策略：
* [preemptive](#preemptive)
* [cooperative](#cooperative)

在一个preemptive系统中，一个任务在它的执行时间里被赋予了优先权，这意味着scheduler能够根据系统所处的阶段将处理器分配给其他的任务。对于需要长执行时间的任务来说，赋予优先权是一个非常好的方法；重要性更高的任务将比重要性低的任务更有效地利用处理器。

在一个cooperative系统中，每一个任务在它的执行时间里独占CPU。除非任务自动放弃对处理器的控制，否则任务间的切换不会出现。

两种调度方式：静态调度（根据时间来进行调度）和动态调度（根据事件来调度）。

在静态调度方式下，提前定义了任务的执行顺序。在动态调度的方式下，一个任务在运行其间是否被执行由系统状态来决定。Scheduler(调度器)根据当前的任务状态进行调整。

在动态调度方式下，只有当存在实际需要时(出现一个外部事件)，处理器才执行任务，处理器的能力将得到更有效的利用(这与静态调度方式无关)。

三个常用任务调度方法: [Priority control](#Priority-controlled)(优先权控制法)，[time slice](#Time-slice)(时间片法)，[FIFO](#FIFO)(first in first out)。（多种方法可以组合）

#### Priority-controlled

priority-controlled (优先权控制)中，OS根据每一个任务的重要程度赋予一个优先级。开发者可以利用优先级来控制一个任务执行的速度和频率。这意味着拥有更高优先权的任务将被更快的执行完毕。可能有这样一种实施方式，所有任务位于不同优先级的队列中（在同一个队列中的任务拥有同样的优先权）。当所有拥有更高优先权的队例为空（被调度执行完毕），特定队例中位于前面的任务将被调度执行。在同一个优先权队列内部，任务同样需要调度。因为优先权相等，需要某种其他的机制来决定不同任务的先后调度顺序。比如说FIFO(先来先出)或者其他技巧。具有代表意义的是，优先权控制法一般与动态调度结合在一起，执行顺序非静态；和preemptive调度结合以允许拥有更高优先权的任务优先执行。

#### Time-slice

Time slice(时间片法)，一个小的时间单元，被定义用来执行任务。一个最简单的情况就是所有的时间片拥有同样的时间长度，也可以拥有不同的长度。所有将被执行的任务列成一个环形的队列，新激活的任务被添加到这个环形队列的尾部。CPU调度器浏览整个队列，为每一个任务分配时间片。对于任务而言，时间片末端点是一个期限，任务将被终止或暂时停止。如果任务在时间片结束前完成，那么它将会主动释放掉处理器。当同时出现多个拥有同样优先级的任务竞争使用CPU时，经常要用到时间片法。时间片法是最简单的，也是应用得最广的CPU调度算法之一，但是这种调度方法并没有以一种最有效的方法来利用CPU能力。因为当一个任务在时间片末端点之前结束的话，在下一个任务执行之前，CPU总是处理空闲状态。

#### FIFO

FIFO（first come first server）排序法中，所有的任务被平等的置于一个队列中。他们按照在队列中的顺序被执行。在复杂程度较低或对顺序性要求较高的系统中，这是一种非常简单而合适的调度机制。


#### 如果两个就绪的任务有相同的优先级该怎么办？

答案取决于使用的实时操作系统，至少有一个系统通过将两个具有同样优先级的任务标志为非法来解决问题。其他的一些系统在两个这样的任务之间平等分配时间片。还有的系统将运行其中的一个直到它阻塞，然后再运行另一个。最后一种情况下，两个任务的哪一个运行也取决于特定的RTOS。

* 抢占式实时操作系统只要一个更高优先级的任务解除了阻塞，就将停止低优先级的任务的运行。

* 非抢占式实时操作系统只会在低优先级任务阻塞厚才会占用其处理器。

 [重头再读](#RTOS简介)