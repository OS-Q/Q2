# [RTOS简介](https://github.com/OS-Q/RTQ)

RTOS并不保证最终的结果是实时的，实时结果的保证要求软件的正确开发。RTOS并不要求高性能，RTOS更为专注于执行时间的保证: 根据对实时性的区分度，分为一般截止时间的保证(软实时性soft real-time)和严格意义上截止时间的保证(硬实时性hard real-time)。

RTOS使用特定的调度算法，并在最终系统中提供给开发人员以必要的工具，确保其应用的实时性。

RTOS的性能主要用最短响应时间或最长预期反应时间或最大超时完成时间来衡量。 RTOS中最关键的因素在于最小的中断时延和最小的线程切换时延。

在一个RTOS中所写的软件的基本构造块就叫任务。任务写起来非常简单：在大多数的RTOS中的一个任务只是一个子程序。

任务(Task)是RTOS中最重要的操作对象，每个任务在RTOS的调用下由CPU分时执行。激活的或当前任务是CPU正在执行的任务，休眠的任务是在存储器中保留其执行的上下文背景、一旦切换为当前任务即可从上次执行的末尾继续执行的任务。任务的调度目前主要有时间分片式(TimeSlicing)、轮流查询式(Round-Robin)和优先抢占式(Preemptive)三种,不同的RTOS可能支持其中的一种或几种，其中优先抢占式对实时性的支持最好。

## 任务状态

* Runnig(运行) - 在这种状态下任务得到了CPU时间来执行它的指令。

在同一个时间点，只有一个任务能够处于这种状态。我们用RTOS的一个函数来将这种状态下的任务变回Suspended状态，这样任务就停止执行并且deactivated.我们用另一个RTOS的函数来这种状态下的任务变到Waiting状态，这时任务同样停止了执行，但是保持活动状态。
注:在多处理器系统里,在指定的时间里可能有超过一个的任务在运行.但是单处理器平台上,任何时候只能有一个任务在单独运行。

* Ready(就绪) - 任务在这种状态下是活动的并且等待进入Running状态。

我们用RTOS的调度器(scheduler)来决定在什么时候将处于Ready的任务过渡到Running状态，我们也用调度器来决定是否将任务变回到Ready状态，这取决于RTOS固有的算法以及其他任务的状态。其他的任务正在运行中,但只要处理器处于空闲状态,这个任务就能运行。大多数的任务可能会处于这个状态。

* Blocked( 阻塞) - 表示任务还没有获得运行所需要的资源，即使此时微处理器空闲也不能运行。

任务处于这个状态是因为它们在等待某些外部事件的发生。例如，处理网络数据的任务在没有数据的时候什么事情也不会做。响应用户按键事件的任务直到用户按键之后才开始工作。处于这个状态的任务有可能也存在许多。

* Suspended(挂起) - 这是系统启动后的默认状态。在这种状态下，任务为inactive。通过RTOS的激活，任务状态可以过渡为Ready。

* Waiting(等待) – 在这种状态下的任务在event(RTOS的另外一个service)进行等待。如果这个event被设置了的话，任务就变回Ready状态。

* Sleep(睡眠) - TBD(To Be Defined)
* Delay(延迟) - TBD(To Be Defined)

